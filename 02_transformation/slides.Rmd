---
title: 'Lecture 2'
subtitle: 'Data transformation'
output:
  xaringan::moon_reader:
    css: [default, default-fonts, "../custom.css"]
    mathjax: "https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"
    nature:
      highlightStyle: tomorrow
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tidyverse)
library(palmerpenguins)
#data(package = 'palmerpenguins')
knitr::opts_chunk$set(echo = TRUE, comment = "")
knitr::opts_chunk$set(fig.dim=c(4.8, 4.5), fig.retina=2, out.width="100%")
```

# Data wrangling

Much of the data wrangling I do daily (and it is daily!) can be done using only a handful of functions, the majority taken from the package `dplyr`, with a few extras from other packages such as `tidyr`.

Essentially, the `dplyr` package provides a bunch of "verbs" (functions) for transforming data. It is similar to SQL if you have done any database work.

It is part of the `tidyverse` set of packages: https://www.tidyverse.org

```{r, echo=FALSE, message=FALSE}
hrc <- read_csv(here::here("data/horizons_river_quality/horizons_river_ecoli.csv"))
```

---

class: middle

# `dplyr`

---

## `dplyr`

Just like `ggplot2` is a grammar of graphics, `dplyr` is a grammar of data manipulation.

It consists of a set of verbs that help us solve the most common data manipulation challenges:

- `select` to choose variables (columns) by name.
- `filter` to choose observations (rows) by value.
- `mutate` to add new variables based of existing variables.
- `summarise` to reduce multiple values down to a single summary.
- `arrange` changes the order of rows.

All of these combine with `group_by` to do all the above operation on subgroups of the data.

---

## `dplyr`

One of the nice things about `dplyr` is it abstracts the language of data processing across the implementation of where the data exist.

It works with `data.frame`'s loaded into memory, as well as remote databases (via SQL, or Apache Spark) using the same set of R commands.

The other nice thing is the consistency:
 - All verbs take in as their first argument a `data.frame`.
 - Then all other arguments describe what to do with the `data.frame`.
 - The result is then a new `data.frame`.

```{r eval=FALSE}
new_data = do_something(old_data, other, stuff)
```
 
---

## Filtering rows with `filter`
 
Let's look at the horizons council river data:
 
```{r}
hrc
```

---

## Filtering rows with `filter`
 
What if we just wanted the rows from 2017 onwards?
 
```{r}
filter(hrc, Date >= '2017-01-01')
```

---

## Filtering rows with `filter`
 
What if we wanted rows with large counts?

```{r}
filter(hrc, Value > 100000)
```

---

## Filtering rows with `filter`
 
What if we wanted really low counts before 2010?

```{r}
filter(hrc, Value < 100, Date <= '2010-12-31')
```

---

## Filtering rows with `filter`
 
What if we wanted the extreme low or high counts?

```{r}
filter(hrc, Value < 3 | Value > 100000)
```

---

## Logical expressions in R

The `filter` argument is a logical expression. i.e. it's something that evaluates to `TRUE` or `FALSE`.

For convenience, filter can take more than one logical expression, separated by a comma. In this case they're AND'd together (i.e. rows must satisfy both criteria), but anything within each expression is done first.

If we want to use OR rather than AND, we use the vertical bar `|` character.

i.e. `filter(hrc, Value < 3 | Value > 100000, SiteID == "00081")`

will return rows where the value is very small or very large from Site 00081.

---

## Logical expressions in R

Notice that for 'is equal to' we've been using `==`. The single `=` is for assignment of parameters instead. `dplyr` will warn you about this:

```{r, error=TRUE}
filter(hrc, Value = 4)
```

**This is rare** - usually error messages are rather more opaque!

Reading carefully, and searching the error on google can sometimes help.

---

## Logical expressions in R

Other operations are `!=` (not equal to) and `%in%` (in). e.g.

```{r}
filter(hrc, Value %in% c(3,5))
```

---

## Dealing with missing values

Notice the `Symbol` column is full of `NA` which means "missing". Maybe there are some that aren't missing? We might try:

```{r}
filter(hrc, Symbol != NA)
```

This seems like it might have worked?? It says there are no rows returned...

--

```{r}
filter(hrc, Symbol == NA)
```

Hmm, that doesn't seem right??

---

## Dealing with missing values

.left-code[
The key thing to remember is if a value is missing, then comparing it is senseless:

```{r}
2 == NA
NA == NA
```

Is 2 equal to something missing?

Maybe! We don't know! So the answer is missing.
]

--
.right-plot[
We use `is.na()` instead for this.

```{r}
is.na(2)
is.na(NA)
```
]

RStudio will remind you about this with a yellow warning in the margin, as it's a common problem.
---

## Dealing with missing values

Notice the `Symbol` column is full of `NA` which means "missing". Maybe there are some that aren't missing?

```{r}
filter(hrc, !is.na(Symbol))
```

Ok, it seems like we have a few (233) numbers where the count actually means less than or greater than the value given, rather than equal to the value given.

---

## Arranging rows with `arrange`

Rather than pick rows out, we can sort the data instead.

```{r}
arrange(hrc, Value)
```

---

## Arranging rows with `arrange`

Selecting more than one variable to arrange on will first arrange on the first, then use later variables for ties:

```{r}
arrange(hrc, Value, Date)
```

---

## Arranging rows with `arrange`

To arrange descending rather than ascending, we can use `desc`

```{r}
arrange(hrc, Value, desc(Date))
```

Interestingly, no value of 1 after 2012... This suggests a change in the way things were measured.

---

## Combining `filter` and `arrange`

Let's look at post-2013 values:

```{r}
after2012 = filter(hrc, Date >= '2013-01-01')
arrange(after2012, Value)
```

It seems some of the values recorded as 4 actually mean "less than 4".

---

## Combining `filter` and `arrange`

```{r}
large_values = filter(hrc, Value > 50000)
arrange(large_values, Site, Date)
```

---

## The pipe `%>%`

Each of the verbs in `dplyr` take a dataset in as the first parameter, and return a data frame out again.

Often, an analyses will consist of a bunch of verbs called one after the other, with each one feeding into the next.

```{r, eval=FALSE}
large_values = filter(hrc, Value > 50000)
arrange(large_values, Site, Date)
```

The temporary dataset `large_values` is really only used here to feed to the `arrange()` verb. We don't really need it.

We could do:

```{r, eval=FALSE}
arrange(filter(hrc, Value > 50000), Site, Date)
```

But you have to read that 'inside out'!

---

class: middle

# The pipe `%>%`

---

## The pipe `%>%`

The pipe operator, `%>%` is specifically designed to improve this. It takes the item on the left of the pipe and places it
as the first argument of the function on the right.

```{r, eval=FALSE}
hrc %>% filter(Value > 5000)
```

Is equivalent to:

```{r, eval=FALSE}
filter(hrc, Value > 5000)
```

But, the pipe version is readable as "Take the dataset `hrc` and filter it so that rows with Value > 5000 remain"

To enter a pipe in RStudio, you can use Ctrl-Shift-M (Command-Shift-M on a Mac).

---

## The pipe `%>%`

This extends naturally:

```{r, eval=FALSE}
hrc %>%
  filter(Value > 5000) %>%
  arrange(Site, Date)
```

reads "Take the dataset `hrc`, filter it so that rows with Value > 5000 remain, then arrange by Site and Date"

When constructing pipelines like this, make sure the `%>%` symbol is at the end of intermediate lines.

.left-code[
Use this:

```{r, eval=FALSE}
hrc %>%
  filter(Value > 5000) %>%
  arrange(Site, Date)
```
]

.right-plot[
Not this:

```{r, eval=FALSE}
hrc
 %>% filter(Value > 5000)
 %>% arrange(Site, Date)
```
]

---

## Selecting and renaming columns

Just like we can select rows with `filter`, we can choose columns with `select`.

This is useful for getting rid of columns we don't need, for rearranging columns, and for changing names to
something more convenient.

```{r}
hrc %>% select(Site, Date, Value)
```

---

## Selecting columns with `select`

We can select a range of columns with a colon `:`

```{r}
hrc %>% select(Council, Site:RawValue)
```

---

## Selecting columns with `select`

We can select by column number instead of column name if you like:

```{r}
hrc %>% select(Council, 3:6)
```

Generally it's better to use names though, as the order of columns might be different to what you expect.

---

## Selecting columns with `select`

The `everything()` helper function is useful if you want one column first, then everything else:

```{r}
hrc %>% select(Symbol, Value, everything())
```

---

## Selecting columns with `select`

The `starts_with()` helper is useful if you have a bunch of columns that start similarly:

```{r}
hrc %>% select(Date, Value, starts_with("Site"))
```

---

## Selecting columns with `select`

You can rename a column just by changing it's name in the `select`:

```{r}
hrc %>% select(Site, Date, EColi = Value)
```

---

## Dropping columns

To drop a column use the `-` in front of the name:

```{r}
hrc %>% select(-parameter, -RawValue, -Symbol)
```

---

## Renaming columns with `rename`

If you want to rename a column but don't want to specify all the other columns, then `rename()` does this:

```{r}
hrc %>% rename(Name = Site)
```

---

## Adding new columns: `mutate`

We can add new columns based on existing ones with `mutate`:

```{r}
hrc %>% select(SiteID, Date, Value) %>%
  mutate(Log10Value = log10(Value))
```

---

## Adding new columns: `mutate`

We can add new columns based on existing ones with `mutate`:

```{r, message=FALSE}
library(lubridate)
hrc %>% select(SiteID, Date, Value) %>%
  mutate(Year = year(Date), Month = month(Date, label=TRUE))
```

---

.left-code[
## Seasonality?
```{r, label='hrc_season', eval=FALSE}
hrc %>%
  mutate(
    Month = month(Date, label=TRUE)
    ) %>%
  ggplot() +
  geom_boxplot(
    aes(
      x = Month,
      y = Value)
    ) +
  scale_y_log10(
    labels = scales::label_comma()
  )
```

We can pipe the result of wrangling into
`ggplot()` as it takes a data.frame as first
argument.

Remember to switch from `%>%` to `+` !!
]

.right-plot[
```{r, ref.label='hrc_season', echo=FALSE, eval=TRUE}
```
]

---

## Adding new columns: `mutate`

We can change existing columns by overwriting them:

```{r}
library(lubridate)
hrc %>% select(SiteID, Date, Value) %>%
  mutate(SiteID = as.numeric(SiteID))
```

---

## Adding new columns: `mutate`

We can change existing columns by overwriting them:

```{r}
hrc %>% select(SiteID, Site, Date, Value) %>%
  mutate(SiteID = as.numeric(SiteID),
         Site = str_to_title(Site))
```

---

## How I extracted value, symbol

.left-code-wide[
```{r, label="hrc_extract", eval=FALSE}
hrc %>% select(SiteID, RawValue) %>%
  mutate(
    Symbol = str_extract(RawValue, '[<>]'),
    Value = str_extract(RawValue, '[0-9]+'),
    Value = as.numeric(Value)
    ) %>%
  arrange(Symbol)
```

The patterns `[<>]`, `[0-9]+` are **regular expressions**.

They're a way of specifying how to match parts of text.

Knowing regular expressions really helps with data wrangling - I often google how to do it each time though!
]

.right-out-narrow[
```{r, ref.label="hrc_extract", echo=FALSE, eval=TRUE}
```
]

---

class: middle

# Summarising rows

---

## Summarising rows with `summarise`

`summarise` computes summary statistics across all rows.

It generally takes lots of rows, performs some computation on one (or more) columns, and results in a single row output.

e.g. you can use this to compute means, medians, counts, totals or other summary statistics:

```{r}
hrc %>% summarise(Mean = mean(Value))
```

---

## Summarising rows with `summarise`

You can do as many summaries at once as you like:

```{r}
hrc %>% summarise(Mean = mean(Value),
                  Median = median(Value),
                  IQR = IQR(Value),
                  Count = n(),
                  Total = sum(Value),
                  Mean2 = Total / Count)
```

Notice in the `Mean2` computation, we're using columns that we computed earlier in the same `summarise()` command.

The `n()` function is useful for number of rows. Also `n_distinct()` for the number of distinct values.

---

## Summarising rows with `summarise`

You can use summaries that produce more than one result, and they'll be placed in multiple rows:

.pull-left[
```{r}
hrc %>%
  summarise(
    Quantile = quantile(Value)
    )
```

But, you need to make sure you know which is which!
]

--

.pull-right[
```{r}
hrc %>%
  summarise(
    Prob = c(0,0.25,0.5,0.75,1),
    Quantile = quantile(Value, probs=Prob)
    )
```

**Sticking to summaries that return a single value is safest.**
]

---

## Summarising rows with `summarise`

This can be combined with the other functions. e.g. to find a summary of counts at a common swimming location in summer:

```{r}
hrc %>%
  mutate(Month = month(Date, label = TRUE),
         Year = year(Date)) %>%
  filter(Site == "manawatu at u/s pncc stp",
         Month %in% c("Dec", "Jan", "Feb"),
         Year >= 2013) %>%
  summarise(Median = median(Value), Maximum = max(Value))
```

A count of 690 means the risk is around 6% of getting sick. The median risk is less than 0.1%.

---

class: inverse
background-image: url("graphics/hrc-00080.jpg")

---

class: middle

# Grouping

---

## Grouping with `group_by`

The power of `dplyr` is that it can do all of the previous actions on subgroups of the data (all at once) rather than the entire data.

.pull-left[
```{r}
hrc %>% select(SiteID, Date, Value)
```
]

.pull-right[
```{r}
hrc %>% select(SiteID, Date, Value) %>% 
  group_by(SiteID)
```
]

---

.pull-left[

## Grouping with `group_by`

So while this produces a single row:

```{r}
hrc %>%
  summarise(Median = median(Value))
```
]

--

.pull-right[
## &nbsp;

This produces multiple rows, one for each year:

```{r}
hrc %>% mutate(Year = year(Date)) %>%
  group_by(Year) %>% 
  summarise(Median = median(Value))
```
]

---

```{r}
hrc %>%
  mutate(Year = year(Date)) %>%
  group_by(Year) %>% 
  summarise(Median = median(Value))
```

Notice the message here: `summarise` has ungrouped the output. This is because the groups no longer matter, as each group has just 1 row anyway.

---

## Grouping multiple variables

When you `group_by()` at more than one variable, the other verbs operate within unique combinations of those variables.

If you do a `summarise()` then you reduce the data down to one row for the inner-most variable. So it will drop this level of grouping, retaining grouping at higher levels.

```{r}
hrc %>%
  mutate(Year = year(Date)) %>%
  group_by(Site, Year) %>%
  summarise(Median = median(Value))
```

---

This means that subsequent operations happen at the `Site` level:

```{r}
hrc %>%
  mutate(Year = year(Date)) %>%
  group_by(Site, Year) %>%
  summarise(Median = median(Value)) %>%
  mutate(Overall = median(Median))
```

---

You can remove grouping with `ungroup()`:

```{r}
hrc %>%
  mutate(Year = year(Date)) %>%
  group_by(Site, Year) %>%
  summarise(Median = median(Value)) %>%
  ungroup() %>%
  mutate(Overall = median(Median))
```

---

## Counting

Another really helpful function that isn't one of the 6 main functions is `count()`.

```{r, eval=FALSE}
hrc %>% count(Site)
```

is equivalent to:

```{r, eval=FALSE}
hrc %>% group_by(Site) %>% summarise(n = n())
```

The function `add_count()` adds a count column instead of summarising.

---

.pull-left[
```{r}
hrc %>% count(Site)
```
]
.pull-right[
```{r}
hrc %>% add_count(Site) %>%
  select(Site, Value, n)
```
]

---

## Other helpers

`slice_min()` and `slice_max()` are useful for finding the top (or bottom) few entries.

.pull-left[
```{r}
hrc %>% select(Site, Value) %>%
  arrange(desc(Value)) %>%
  filter(row_number() <= 10)
```
]

.pull-right[
```{r}
hrc %>%
  select(Site, Value) %>%
  slice_max(Value, n=10)
```
]

---

## Other helpers

There are also `slice()` for taking rows out by row number, or `slice_head()` and `slice_tail()` for taking from the ends. `slice_sample()` can be used to take a random sample.

```{r}
hrc %>% slice_sample(n=10)
```

---

## Putting it all together

With the 6 main functions `select`, `arrange`, `filter`, `mutate`, `summarise` and `group_by` we can now answer many questions:

- Which are the best or worst sites on average (e.g. by Median)?

- Which sites do we not have much data on?

- Which sites are new?

- Which sites are tested infrequently?

---

Which sites are the **best** on average (by median)

```{r}
hrc %>% group_by(Site) %>%
  summarise(Median = median(Value)) %>%
  arrange(Median)
```

---

Which sites are the **worst** on average (by median)

```{r}
hrc %>% group_by(Site) %>%
  summarise(Median = median(Value)) %>%
  arrange(desc(Median))
```

---

Which sites are the **best** or **worst** on average (by median)

.pull-left[
```{r, message=FALSE}
hrc %>% group_by(Site) %>%
  summarise(Median = median(Value)) %>%
  slice_min(Median, n=5)
```
]

.pull-right[
```{r, message=FALSE}
hrc %>% group_by(Site) %>%
  summarise(Median = median(Value)) %>%
  slice_max(Median, n=5)
```
]

---

Which sites do we not have much data on?

```{r}
hrc %>% count(Site) %>% arrange(n)
```

---

Which sites are new?

```{r}
hrc %>% group_by(Site) %>%
  summarise(FirstDate = min(Date)) %>%
  arrange(desc(FirstDate))
```

---

Which sites are tested infrequently?

```{r}
hrc %>% group_by(Site) %>%
  summarise(DateRange = max(Date) - min(Date), Count = n()) %>%
  mutate(DaysPerTest = DateRange / Count) %>%
  arrange(desc(DaysPerTest))
```

---

class: middle

# Combining data

---

## Combining data through joins

It is common to receive data in several different spreadsheets.

e.g. if doing a study where samples are taken from animals across farms, you might have a samples spreadsheet, an animals spreadsheet, and a farms spreadsheet.

For final analyses on samples, however, you might want to assess animal or farm-level effects on outcomes at the sample level.

Thus, you'll need to combine the data from these spreadsheets together into a single `data.frame`.

In RStudio, we do this using **joins** in `dplyr`.

---

## Data sets

We'll use a couple of datasets from the Star Wars movies for this.

```{r, message=FALSE}
characters <- read_csv("https://www.massey.ac.nz/~jcmarsha/161122/sw_characters.csv")
characters
```

---

## Data sets

We'll use a couple of datasets from the Star Wars movies for this.

```{r, message=FALSE}
films <- read_csv("https://www.massey.ac.nz/~jcmarsha/161122/sw_films.csv")
films
```

---

## Joining with `dplyr`

There are two main types of join in dplyr: **mutating joins** and **filtering joins**.

- Mutating joins add new columns from the additional dataset.

- Filtering joins filter out existing columns based on information in the additional dataset.

For both, we need a set of 'primary' or 'key' columns: these are columns that share the same
information so we can merge the datasets together.

e.g. The `films` and `characters` datasets share the `name` column, so that will be our key.

---

## Mutating joins

There are four separate mutating joins:

- `left_join(x,y)` returns all rows in x, and all rows that match these in y. If y doesn't have a match, `NA` will be used.

- `right_join(x,y)` returns all rows in y and all rows that match these in x. If x doesn't have a match in y, `NA` will be used.

- `inner_join(x,y)` returns only rows in x and y that have a match.

- `full_join(x,y)` returns all rows in x and all rows in y. Anything in x or y that don't have a match will be filled with `NA`.

---

.pull-left[
## Left join

`left_join()` returns all rows in the 'left' data set and anything that matches in the right.
]

.pull-right[
![](graphics/joins/left-join.gif)
]

---

.pull-left[
## Left join

`left_join()` returns all rows in the 'left' data set and anything that matches in the right.

If there's more than one matching row on the right, both are returned.
]

.pull-right[
![](graphics/joins/left-join-extra.gif)
]

---

`left_join()` returns all rows in the 'left' data set and anything that matches in the right.

```{r}
characters %>% left_join(films)
```

---

.pull-left[
## Right join

`right_join()` returns all rows in the 'right' data set and anything that matches in the left.
]

.pull-right[
![](graphics/joins/right-join.gif)
]

---

`right_join()` returns all rows in the 'right' data set and anything that matches in the left.

```{r}
characters %>% right_join(films)
```

---

.pull-left[
## Inner join

`inner_join()` returns only rows in both data sets. No `NA` from the join.
]

.pull-right[
![](graphics/joins/inner-join.gif)
]

---

`inner_join()` returns only rows in both data sets. No `NA` from the join.

```{r}
characters %>% inner_join(films)
```

---

.pull-left[
## Full join

`full_join()` returns all rows in both data sets. Anything that doesn't match gets `NA`.
]

.pull-right[
![](graphics/joins/full-join.gif)
]

---

`full_join()` returns all rows in both data sets. Anything that doesn't match gets `NA`.

```{r}
characters %>% full_join(films)
```

---

## Mutating joins

The `left_join()` is the one I use the most.

Reason is you almost always start with the dataset that has the outcomes you want
in it, and are joining back to explanatory things.

---

## Filtering joins

The two filtering joins only return columns in x. They are:

- `semi_join(x,y)` returns rows in x with a match in y.

- `anti_join(x,y)` returns rows in x that don't have a match in y.

i.e. `semi_join` is for keeping things in, `anti_join` is to filter things out.

---

.pull-left[
## Semi join

`semi_join` will return the characters which are in one or more of our films.
]

.pull-right[
![](graphics/joins/semi-join.gif)
]

---

## Semi join

`semi_join` will return the characters which are in one or more of our films.

```{r}
characters %>% semi_join(films)
```

---

.pull-left[
## Anti join

`anti_join` will return the characters which aren't in any of our films.
]

.pull-right[
![](graphics/joins/anti-join.gif)
]

---

## Anti join

`anti_join` will return the characters which aren't in any of our films.

```{r}
characters %>% anti_join(films)
```

